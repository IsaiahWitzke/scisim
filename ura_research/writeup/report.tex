\documentclass[12pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{hyperref}
% \usepackage{kpfonts}
% \newcommand*{\vv}[1]{\vec{\mkern0mu#1}}
\newcommand{\GA}{G_{\mathbb{A}}}
\newcommand{\bigA}{{\mathbb{A}}}
\newcommand{\pd}[2]{\cfrac{\partial{#1}}{\partial{#2}}}
\newcommand{\dist}[2]{\text{dist(} #1 \text{, } #2 \text{)}}
\newcommand{\ball}[1]{\text{ball(} #1 \text{)}}
\newcommand{\proj}[2]{\text{proj}_{#1}(#2)}
\newcommand{\realm}[2]{ M_{#1 \times #2}(\mathbb{R})}
\begin{document}


\section{The code}

\subsection{Introduction to the scisim C++ code and what's important for us}

This "scisim" repository was created and used years ago by the researchers that wrote the "Rosi paper"
(i.e. "Reflections on Simultaneous Impact" by Rosi et al.).
Scisim is a pretty large codebase, and is capable of running some cool simulations,
however in the current stage of our URA project \textit{most} of the codebase is irrelevant.
I.e., scisim can handle 3d simulations, friction effects, complex geometry, ...,
but we're using Scisim just to simulate comparatively simple 2d ball collisions.

The most relevant C++ code for us is found in the \texttt{ImpactOperator}
classes (see the \texttt{scisim/ConstrainedMaps/ImpactMaps/} folder).
More specifically, we are interested in the \texttt{ImpactOperator::flow} method.
\\\texttt{ImpactOperator::flow} is responsible for collision response:
When Scisim detects that one or more balls will collide in the next time-step, \texttt{flow} is called
to determine how the colliding balls' velocities will change as a result of the collision.
More verbosely, \texttt{flow} is called with the colliding balls' positions, pre-collision velocities, masses, etc,
and it must find the "normalized impulse coefficients" $\lambda$.
$\lambda$ in turn will yield the balls' correct post-collision velocities,
since $\dot{q}^+ = \dot{q}^- + M^{-1} \GA{} \lambda$ (more details on this in the Rosi paper).

The goal of our research is to find a \texttt{ImpactOperator::flow} implementation which finds $\lambda$ fast!

\subsection{Variable name discrepancies}


It's worth noting that there are some variable name differences between the Rosi paper and the code
-- it caused some confusion when I was first going through it.
\begin{itemize}
    \item $\GA{}$ is referred to as \texttt{N} in the code
    \item $\dot{q}^-$ is called \texttt{v0}
    \item $\lambda$ is sometimes called \texttt{alpha} and sometimes just "\texttt{solution}".
\end{itemize}

\subsection{Running scisim \& scene files}

Let's see some balls colliding!

\texttt{cd} into the \texttt{scisim/build/rigidbody2dqt4} directory and run \texttt{make} to compile the code.
Then to start a simulation, run the compiled \texttt{rigidbody2d\_qt4} executable and provide a path to an xml ``scene'' file:
\\\begin{verbatim}
./rigidbody2d_qt4 ../../ura_research/scenes/simple/10_balls_in_box.xml
\end{verbatim}

There's a lot of different scene files that you can use in the \texttt{ura\_research/scenes/} directory.
There's also some left-over scenes under the
\\\texttt{ura\_research/src/archive/old\_simulation\_data/} directory,
but these probably aren't very interesting nor useful anymore.
Finally, the creators of Scisim left some interesting scenes in \texttt{assets/rigidbody2d/} that are fun to play around with.

These scene xml files define the objects (balls, walls, etc...) in the simulation and their initial properties
(positions, velocities, masses, coefficients of restitutions, etc...).
The scene files also define the "impact operator" that will be used to resolve collisions over the duration of the simulation.
This is done in the \texttt{<solver>} tag of the scene file, which can usually be found near the top.
In the example above, we used the \texttt{10\_balls\_in\_box.xml} scene,
which specifies \texttt{"ipopt"} as the solver.
This means that
\\\texttt{scisim/ConstrainedMaps/ImpactMaps/LCPOperatorIpopt.cpp}'s \texttt{flow}
implementation is used to resolve collisions
(see \texttt{RigidBody2dSceneParser} line 710 for \textit{why};
this is relevant if you want to make your own ImpactOperator).

\subsection{Impact operators of interest}

There are a couple different ImpactOperator implementations that we're interested in:


\begin{itemize}{}{\setlength{\leftmargin}{0.25cm}}
    \item \texttt{LCPOperatorIpopt.cpp} - an implementation that comes with scisim.
    Uses the IPOPT algorithm to find $\lambda$.
    Ipopt is widely used for "large scale nonlinear optimization of continuous systems"
    (\href{https://en.wikipedia.org/wiki/IPOPT}{wikipedia}) and does a good job in our case -
    it's a very robust (i.e. converges on a correct solution every time), but not very fast.
    The reason that it's not super fast is because it's a general purpose solver,
    not tuned for our specific collision problem. Hence our goal of finding a faster solver!
    
    \item \texttt{LCPOperatorPenalty.cpp} - an implementation that a previous student, Wen Zhang wrote.
    Uses a penalty method to find $\lambda$. See Zhang's URA writeup for more details on it's performance.
    I believe this implementation is faster than Ipopt, but it's not as robust.
    Over the past 2 research terms we haven't returned to this method, although there's potentially some progress to be made here.
    Right now we don't fully understand why the current penalty method fails sometimes.

    \item *\textbf{\texttt{LCPOperatorPI.cpp}}* - an implementation that a previous student, Kevin Wan wrote.
    Uses policy iteration method.
    Not very robust in it's current state, but very fast when it does work.
    \textbf{This is the implementation that current efforts are focused};
    it shows the most speed gain potential, we just need to make it more reliable.

    \item \texttt{LCPOperator3.cpp} - 
    An amalgamation of the previous 3 implementations - it runs them all side-by-side and reports the differences in solutions after all have completed.
    Used for analysis/debugging purposes.

    \item \texttt{LCPOperatorPIv2.cpp} - an attempted improvement on LCPOperatorPI.
    More on this below.
    
    \item \texttt{LCPOperatorIsaiahDebug.cpp} -
    Similar to the LCPOperator3 in that it runs 3 operators side-by-side for comparison.
    This operator differs from LCPOperator3 right now as it runs LCPOperatorPIv2 instead of LCPOperatorPenalty
    (it still runs the LCPOperatorIpopt and LCPOperatorPI though).
    I've been using this operator as a bit of a sandbox, and regularly update it to get different data out of the C++ simulation.
    It prints out debugging info and collision data when the balls collide (i.e. Q, N, v0, ...) in json format to stdout.
    This allows us to ingest the simulation's state at the time of the collision into python and run our own analysis on it.
    This is the implementation that we're primary using to test ideas, so this operator is used in most of the scene .xml files.
    \\\textbf{**Note**:} this implementation will exit the program after the first call to \texttt{LCPOperatorIsaiahDebug::flow}!
    This is intentional since I've only ever wanted to do analysis on one collision at a time.
\end{itemize}


\section{Python workflow}

In this section we'll go over some of the python source that's been built up over the past term.
Much of it isn't super clean (sorry about that), but most of it won't relevant going forward anyways
(the important bits should be well-documented enough $\ddot\smile$).
For instance, many of the notebooks like \texttt{ura\_research/src/archive/<date>.ipynb}
were just made to test out my "idea of the week", and then never used again!
I just found it really helpful to have a python notebook workflow
where I could import simulation data from Scisim/C++ and quickly test out my ideas in python.
I find playing around with algorithms and preforming analysis is a lot faster and more productive in Python notebooks vs C++
(you'll find it takes a long time for the C++ code to compile).
This philosophy might not hold true for you though, so feel free to move away from using Python going forward.

With that being said, let's take a look at some of the Python tools you have at your disposal.

\subsection{Loading simulation data into a Python notebook}


Let's run a simulation with the \texttt{LCPOperatorIsaiahDebug} operator
and pipe the output to a file:

\begin{verbatim}
./rigidbody2d_qt4 ../../ura_research/scenes/simple/2_balls.xml > \
    ../../ura_research/simulaiton_outputs/2_balls_output.json
\end{verbatim}

We can then import the simulation data into python and analyze it.
See \texttt{ura\_research/src/analyze\_data.ipynb} as an example jupyter notebook that does just this.
In this notebook we use the \texttt{read\_file\_to\_pd\_dataframe} function from \texttt{util/data\_import.py}
to import the simulation data into a pandas dataframe.
The matrices and vectors that are passed to \texttt{LCPOperatorIsaiahDebug::flow} (i.e. N, Q, v0, ...)
are parsed into numpy arrays. Also, Ipopt's solution for $\lambda$ is parsed into a numpy array too.

This means that you can now make your own implementations for \texttt{ImpactOperator::flow} in python
and compare results against Ipopt's solution.
This is exactly what is being doing in \texttt{ura\_research/src/PI\_v2.ipynb}.

that take in the simulation data as input,

Nice! We've effectively pulled some relevant variables from C++ into python.
This means we use pandas and numpy to dig into the collision data much easier than if we had to do everything in C++.



\section{Preamble/Notation}

The primary problem posed in this project, is to find a solution to the following LCP:

find $\lambda \in \mathbb{R}^n$ such that...

$Q\lambda + b \geq 0$, $\lambda \geq 0$, $\lambda^T (Q\lambda + b) = 0$

With
$\mathbf{Q} := \GA^T M^{-1} \GA$,
$\mathbf{b} := \GA^T \dot{q}^- (1 + c_r)$


\section{Result: Relating Q matrix to angles}

What does $Q$ actually represent? Let's simplify for now and assume that $M = I = M^{-1}$
so that $Q = \GA^T M^{-1} \GA = \GA^T \GA$

$\GA \in M_{3m \times n}(\mathbb{R})$
where $n = $ number of collisions (size of "active set"),
and $m = $ the number of balls in the simulation.
Here we assume that each ball has 3 coordinates: an $x, y,$ and a rotation $\phi = 0$
\footnote{
    We aren't yet concerned with friction effects,
    so balls with no rotation initially stay that way during and after collision.
}
(hence $3m$ rows).

Every column of $\GA$ can be written as $(\GA^T)_i = \nabla g_i(q)$.
If $g_i(q)$ is the collision constraint between balls \textbf{a} and \textbf{b},
then, using $a_x, a_y, b_x, b_y$ to represent the indices of the x and y coordinates
of balls a and b respectively:

\begin{align*}
    g(q)    &= \dist{a}{b} \\
            % &= \dist{(q_{a_x}, q_{a_y})}{(q_{b_x}, q_{b_y})}\\
            &= \sqrt{(q_{a_x} - q_{b_x})^2 + (q_{a_y} - q_{b_y})^2} - r_a - r_b
\end{align*}

Where $r_a, r_b$ are the radii of balls a and b.\footnote{It's worth noting that this is
the ONLY place where the radius of the balls will appear. Once we take the gradient of $g(q)$
the $r$ constants will disappear.}

The constraint gradient (i.e. the columns that make up $\GA$) can now be written as:

\begin{align*}
    \nabla g_i(q)
        &= \begin{bmatrix}
            \dots \;
            \pd{\dist{a}{b}}{q_{a_x}} \; \pd{\dist{a}{b}}{q_{a_y}} \;
            \dots \;
            \pd{\dist{a}{b}}{q_{b_x}} \; \pd{\dist{a}{b}}{q_{b_y}} \;
            \dots \;
        \end{bmatrix}^T \\
        &= \begin{bmatrix}
            0 \dots  0 \;
            \pd{\dist{a}{b}}{q_{a_x}} \; \pd{\dist{a}{b}}{q_{a_y}} \;
            0 \dots 0 \;
            \pd{\dist{a}{b}}{q_{b_x}} \; \pd{\dist{a}{b}}{q_{b_y}} \;
            0 \dots 0 \;
        \end{bmatrix}^T \\
        &= \begin{bmatrix}
            0 \dots 0 \;
            \cfrac{q_{a_x} - q_{b_x}}{\dist{a}{b}} \; \cfrac{q_{a_y} - q_{b_y}}{\dist{a}{b}} \;
            0 \dots 0 \;
            \cfrac{q_{b_x} - q_{a_x}}{\dist{a}{b}} \; \cfrac{q_{b_y} - q_{a_y}}{\dist{a}{b}} \;
            0 \dots 0 \;
        \end{bmatrix}^T
\end{align*}

Notice that the sub-vector
$\vec{n_{ab}}
    := \begin{bmatrix}
        \pd{\dist{a}{b}}{q_{a_x}} \; \pd{\dist{a}{b}}{q_{a_y}}
    \end{bmatrix}^T
    = \begin{bmatrix}
        \cfrac{q_{a_x} - q_{b_x}}{\dist{a}{b}} \; \cfrac{q_{a_y} - q_{b_y}}{\dist{a}{b}}
    \end{bmatrix}^T$
which is made up of the first 2 non-zero values of $\nabla g_i(q)$
is the collision normal vector $\vec{n_{ba}}$!
Similarly, the other 2 non-zero entries of $\nabla g_i(q)$ make up the opposing 
collision normal: $-\vec{n_{ba}} = \vec{n_{ab}}$

Now we know what the columns of $\GA$ consist of, we can look at the individual elements of $Q$:

\begin{align*}
Q_{ij}
    &= \GA^T{_i} \cdot \GA^T{_j}\\
    &= \nabla g_i(q) \cdot \nabla g_j(q)\\
    &= ...
\end{align*}

\subsection*{... 3 Cases} 
\subsubsection*{1: $i = j$ (2 balls)} 

In this case, $Q_{ij} = Q{ii} = \nabla g_i(q) \cdot \nabla g_i(q) = ||\vec{n_{ab}}||^2 + ||\vec{n_{ba}}||^2 = 2$

\subsubsection*{2: $i \neq j$ with 2 separate collisions (4 balls)}

Consider $Q_{ij} = \nabla g_i(q) \cdot \nabla g_j(q)$
where $g_i(q) = \dist{a}{b}$ and $g_j(q) = \dist{c}{d}$. 
i.e. we consider 2 collisions (i,j) involving 4 distinct balls (a,b,c,d).
Here the 4 non-zero entries of
$g_i(q)$ will occur at different indices than the non-zero elements of $g_j(q)$!
\footnote{The $k$th element of $\nabla g_i(q) \neq 0$ means that the $k$th element
is the partial of $g$ w.r.t. either ball a or b. This implies that the $k$th element
of $\nabla g_j(q) = \pd{g_j(q)}{q_k} = 0$ since $k \in \{a_x, a_y, b_x, b_y\}$ and constraint between balls c and d is independent
of a or b's position.}
Therefore: $Q_{ij} = \nabla g_i(q) \cdot \nabla g_j(q) = 0$

\subsubsection*{3: $i \neq j$ with 2 interacting collisions (3 balls)}

The most interesting case! Let's assume WLOG that 3 balls a, b, and c are colliding simultaneously.
WLOG, assume $g_i(q) = \dist{a}{b}$, and $g_j(q) = \dist{b}{c}$ so that $i, j \in \mathbb{A}$.

Then
$Q_{ij}
    = \nabla g_i(q) \cdot \nabla g_j(q)
    = \vec{n_{ab}} \cdot \vec{n_{cb}}
    = |\vec{n_{ab}}||\vec{n_{cb}}|\cos{\theta}
    = \cos{\theta}
$

Where $\theta := \angle abc$

\section*{Result: interpretation of $b$, $Q \lambda$, LCP criteria}

\subsection*{$b$}

$b$ is the other constant value of interest in out LCP. If we assume once again that
$g_i(q)$ is the constraint between balls a and b:

\begin{align*}
    b   &:= \GA^T \dot{q}^-(1 + c_r)\\
    \implies b_i &= (1 + c_r) \nabla g_i(q) \dot{q}^-\\
    &= (1 + c_r) \frac{dg_i}{dt}\\
    &= (1 + c_r) \frac{d(\dist{a}{b})}{dt}\\
\end{align*}
Interpretation: the $b_i$ represents\\
\indent $\mathbf{-(1+c_r)} \times$ (relative speed ball a is approaching ball b).\\
(note the negative sign since $\frac{d(\dist{a}{b})}{dt} \leq 0$)

\subsection*{$Q \lambda$}

From the Rosi paper, we know that $\lambda \in \mathbb{R}^{|\mathbb{A}|}$ is the vector of
impulse coefficients (i.e. $\lambda_i$ is the force that ball a exerts on ball b
***TODO: ensure this is *technically/semantically* correct!)
Now consider the $i$th element of $Q\lambda$:

\begin{align*}
(Q \lambda)_i 
    &= \sum_{j = 1}^{\bigA} Q_{ij} \lambda_j\\
\end{align*}

For $Q_{ij}$ there are 3 cases (see above). Firstly, collision constraint $i$ could
not be affected by either of the balls involved in collision $j$, in which case $Q_{ij} = 0$
and we can ignore those terms. Secondly, there will be a term where $i = j$, in this case
$Q_{ij} = Q_{ii} = 2$. And finally, assume that constraint $i$ is "concerned" with balls a and b,
(i.e. $g_i(q) = \dist{a}{b}$) and $j$ is "concerned" with \textit{either}
ball a or b \textit{and} some 3rd ball c. In this case
$Q_{ij} = \cos(\angle abc)$ or $Q_{ij} = \cos(\angle cab)$.

So, if we set:\\
$A = \{x \in \bigA | s.t. \; g_x(q) = \dist{a}{c}\} \backslash \{i\}$ \\
And $B = \{x \in \bigA | s.t. \; g_x(q) = \dist{b}{c}\} \backslash \{i\}$  \\
Where in both cases c is just a ball that is in the process of colliding with ball a or b respectively, then
we can rewrite above as:

\begin{align*}
(Q \lambda)_i 
    &= \sum_{j = 1}^{\bigA} Q_{ij} \lambda_j\\
    &= 2\lambda_i + \sum_{x \in A}^{} \cos(\angle ba\;\ball{x})\lambda_x + \sum_{x \in B}^{} \cos(\angle ab\;\ball{x})\lambda_x\\
    &= 2\lambda_i
        + ||\sum_{x \in A}^{}\proj{\overrightarrow{n_{ba}}}{\overrightarrow{n_{\ball{x}a}}} \lambda_x||
        + ||\sum_{x \in B}^{}\proj{\overrightarrow{n_{ab}}}{\overrightarrow{n_{a\;\ball{x}}}} \lambda_x||\\
    &= \text{net force acting on balls a and b along direction: } \overrightarrow{n_{ab}}
\end{align*}


TODO: clean up the equation above... using "$\ball(x)$" is confusing... maybe some of the ab should be ba...
theres a little more explaining that could be done. ESPECIALLY relating to our disregard of mass - 
really, the above should be the net $\Delta \dot{q}$ once we bring back $M^{-1}$ and divide each
term by it's balls' masses.

\subsection*{LCP Criteria: $Q\lambda + b \geq 0$}

This is saying for each collision $i \in \bigA$, we need $(Q\lambda)_i \geq -b_i$.
Let $[\dot{q}]_{\overrightarrow{n_{ab}}}$ represent the speed of ball a wrt ball b.\\
As we have seen before, $b_i = -(1 + c_r) [\dot{q}]_{\overrightarrow{n_{ab}}}$
so we can rewrite our lcp condition as:

\begin{align*}
    \text{net force (speed?) acting on balls a and b} \geq (1 + c_r) [\dot{q}]_{\overrightarrow{n_{ab}}}
\end{align*}
\newline{}
Or something like that... basically, the LCP condition is enforcing our solution ($\lambda$,
the impulse coefficients) will result in exiting velocities that conserve momentum.


when we factor in the complementary condition, the times 2 above makes sense!

either $(Q\lambda + b)_i = 0$, in this case $\lambda_i > 0$ and we get

\begin{align*}
(Q \lambda)_i &= \sum_{j = 1}^{\bigA} Q_{ij} \lambda_j\\
    &= 2\lambda_i + \sum_{x \in A}^{} \cos(\angle ba\;\ball{x})\lambda_x + \sum_{x \in B}^{} \cos(\angle ab\;\ball{x})\lambda_x\\
    &= 2\lambda_i
        + ||\sum_{x \in A}^{}\proj{\overrightarrow{n_{ba}}}{\overrightarrow{n_{\ball{x}a}}} \lambda_x||
        + ||\sum_{x \in B}^{}\proj{\overrightarrow{n_{ab}}}{\overrightarrow{n_{a\;\ball{x}}}} \lambda_x||\\
    &= ||\sum_{x \in A}^{}\proj{\overrightarrow{n_{ba}}}{\overrightarrow{n_{\ball{x}a}}} \lambda_x||
        + ||\sum_{x \in B}^{}\proj{\overrightarrow{n_{ab}}}{\overrightarrow{n_{a\;\ball{x}}}} \lambda_x||\\
\end{align*}

basically, our LCP solution in this case requires that the relative exit velocity of balls
a and b is ONLY a result of the forces of the OTHER balls colliding with balls a/b.

Or... wait no nvm lol

TODO: more investigation here perhaps?

\subsection*{result: Q is not generally an "M-matrix"}

This was something we were concerned with in previous semesters of work.
The off-diagonal entries of $Q$ are $\cos \theta$ where $\theta \in [0, \pi]$!
It's easy to imagine a scenario where 2 balls (a and b) 
simultaneously collide with a common 3rd ball (c) so that the angle
connecting the center of the 3 balls $\angle acb < \pi / 2$
and thus $\cos \theta > 0$, ($\implies Q$ cannot be an M-matrix )

TODO: illustration?

\section{overlapping and collisions through balls}

\section{"K3" Example}

Generally speaking, when only 2 balls collide with each other, there isn't much
special going on... $G_\bigA \in \realm{3m}{1}$ so $Q \in \realm{1}{1}$ and $\lambda$ is
really easy to find.

A more interesting scenario can be found when 3 balls collide with each other while all on the same axis.
\footnote{
    This does required that ball collides with ball c \textit{through} ball b... but sadly, because of discrete
    time issues, this is a case that must be considered
}
In this case, all angles are either $0$ or $\pi$, so $Q$ is:
\footnote{Order of values also depend on the order of collisions in the active set.}

\begin{align*}
Q
    &= \begin{bmatrix}
        2 & 1 & -1\\
        1 & 2 & 1\\
        -1 & 1 & 2
    \end{bmatrix}
\end{align*}

Which is singular! There are an infinite number of solutions to the LCP
- and IPOPT does in fact find a different solution to policy iteration!

\section{"K4" Example}

4 balls (all overlapping each other) configured in a square with velocities
towards the center of the square makes a "K4" type of graph where each of the 4 balls
is colliding with the other 3 in the same instant.
This also produces a singular Q matrix (rank = 5, nullity = 1), and
IPOPT/PI yield different solutions.

in both K3 and K4 examples, there are 3 viable control sets.
\end{document}